import java_cup.runtime.*;


parser code  {:
    public static Node root;

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};
// defining terminals here
// arithmetic operators
terminal        PLUS, MINUS, MULTIPLY, DIVIDE, MOD, UMINUS,
				LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL, NOTEQUAL;
// logical operators
terminal	    AND, OR, NOT;
// dot
terminal        DOT;
// types
terminal        String INT, DOUBLE, BOOL, STRING;

// literals
terminal        String DECIMAL;
terminal        String FLOATINGPOINT;
terminal        String BOOLEANLITERAL;
terminal        String STRINGLITERAL;
terminal        NULL;

// signs
terminal		OPENBRACKET, CLOSEBRACKET, OPENCLOSEBRACKET, WS, OPENPARENTHESIS,
				CLOSEPARENTHESIS, OPENCURLYBRACES, CLOSECURLYBRACES;
// keywords
terminal        READINTEGER, READLINE, NEW, NEWARRAY, ITOD, DTOI, ITOB, BTOI,
				VOID, CLASS, INTERFACE,
				EXTENDS, IMPLEMENTS, COMMA, SEMICOLON, PRIVATE, PROTECTED, PUBLIC, IF, ELSE, WHILE, FOR, RETURN,
				BREAK, CONTINUE, PRINT, ASSIGN, THIS;
terminal        String IDENTIFIER;

// defining nonterminals
nonterminal     Program, DeclStar, Decl, VariableDecl, Variable, FunctionDecl, Formals, CommaVariables,
				ClassDecl, ClassDeclExtends, ClassDeclImplements, CommaIdentifiers, FieldStar, Field,
				AccessMode, InterfaceDecl, PrototypeStar, Prototype, StmtBlock, InsideStmtBlock, VariableDeclStar, StmtStar,
				Stmt, ExprPrime, IfStmt, ElsePrime, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt, PrintStmt,
				PrintCommaExpr, ActualsCommaExpr, Actuals;
// non-terminals with type
nonterminal     Type;
nonterminal     LValue;
nonterminal     Expr;
nonterminal     Constant;
nonterminal     Call;

// defining precedences
precedence left     ELSE;
precedence right    ASSIGN;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, NOTEQUAL;
precedence left     LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left     PLUS, MINUS;
precedence left     MULTIPLY, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     DOT, OPENBRACKET;
precedence left     OPENPARENTHESIS;

start with Program;

Program ::=             Decl DeclStar;

DeclStar ::=            Decl DeclStar
						| /*epsilon*/
						;

Decl ::=                VariableDecl
						| FunctionDecl
						| ClassDecl
						| InterfaceDecl
						;

VariableDecl ::=        Variable SEMICOLON;

Variable ::=            Type:type IDENTIFIER:id
						;

Type ::=                INT
						| DOUBLE
						| BOOL
						| STRING
                        | IDENTIFIER:e
						| Type:t OPENCLOSEBRACKET
						;

FunctionDecl ::=        Type:t IDENTIFIER:name OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						| VOID IDENTIFIER:name OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						;

Formals ::=             Variable:v CommaVariables
						| /*epsilon*/
						;
CommaVariables ::=      COMMA Variable CommaVariables
						| /*epsilon*/
						;

ClassDecl ::=           CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements OPENCURLYBRACES FieldStar CLOSECURLYBRACES;
ClassDeclExtends ::=    EXTENDS IDENTIFIER
						| /*epsilon*/
						;
ClassDeclImplements ::= IMPLEMENTS IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
CommaIdentifiers ::=    COMMA IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
FieldStar ::=           Field FieldStar
						| /*epsilon*/
						;

Field ::=               AccessMode VariableDecl
						| AccessMode FunctionDecl
						;

AccessMode ::=          PRIVATE
						| PROTECTED
						| PUBLIC
						| /*epsilon*/
						;

InterfaceDecl ::=       INTERFACE IDENTIFIER OPENCURLYBRACES PrototypeStar CLOSECURLYBRACES;
PrototypeStar ::=       Prototype PrototypeStar
						| /*epsilon*/
						;

Prototype ::=           Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						;

StmtBlock ::=           OPENCURLYBRACES InsideStmtBlock CLOSECURLYBRACES;
InsideStmtBlock ::=     VariableDecl InsideStmtBlock
						| StmtStar
						;
StmtStar ::=            Stmt StmtStar
						| /*epsilon*/
						;

Stmt ::=                ExprPrime SEMICOLON
						| IfStmt
						| WhileStmt
						| ForStmt
						| BreakStmt
						| ContinueStmt
						| ReturnStmt
						| PrintStmt
						| StmtBlock
						;

ExprPrime ::=           Expr:e
						| /*epsilon*/
						;

IfStmt ::=              IF OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt ElsePrime
                        ;

ElsePrime ::=           ELSE Stmt:s
						| /*epsilon*/
                        ;


WhileStmt ::=           WHILE OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt:s;

ForStmt ::=             FOR OPENPARENTHESIS ExprPrime SEMICOLON Expr:e SEMICOLON ExprPrime CLOSEPARENTHESIS Stmt;

ReturnStmt ::=          RETURN ExprPrime:e SEMICOLON
						;

BreakStmt ::=           BREAK SEMICOLON;

ContinueStmt ::=        CONTINUE SEMICOLON;

PrintStmt ::=           PRINT OPENPARENTHESIS Expr:e PrintCommaExpr CLOSEPARENTHESIS SEMICOLON
						;

PrintCommaExpr ::=      COMMA Expr:e PrintCommaExpr
						|
						/*epsilon*/
						;

Expr ::=                LValue:lv ASSIGN Expr:e
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue_ASSIGN_Expr);
                        tmp.getChildren().add((Node) lv);
                        tmp.getChildren().add((Node) e);
                        RESULT = tmp;
                        :}
						| Constant:c
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Constant);
                          tmp.getChildren().add((Node)c);
                          RESULT = tmp;
                        :}
						| LValue:lv
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue);
                          tmp.getChildren().add((Node)lv);
                          RESULT = tmp;
                        :}
						| THIS
    					{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.THIS);
                        // todo
                         RESULT = tmp;
                        :}
						| Call:c
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Call);
                        tmp.getChildren().add((Node)c);
                        RESULT = tmp;
                        :}
						| OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                        tmp.getChildren().add((Node)e);
                        RESULT = tmp;
                        :}
						| Expr:e1 PLUS Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_PLUS_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 MINUS Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MINUS_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 MULTIPLY Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MULTIPLY_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 DIVIDE Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_DIVIDE_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 MOD Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MOD_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| MINUS Expr:e
                        {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.MINUS_Expr);
                        tmp.getChildren().add((Node)e);
                        RESULT = tmp;
                        :}
                        %prec UMINUS
                        | Expr:e1 LESS Expr:e2
                        {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_LESS_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 LESSEQUAL Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_LESSEQUAL_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 GREATER Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_GREATER_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 GREATEREQUAL Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_GREATEREQUAL_Expr);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 EQUAL Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_EQUAL_Expr);
                        tmp.getChildren().add((Node) e1);
                        tmp.getChildren().add((Node) e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 NOTEQUAL Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_NOTEQUAL_Expr);
                        tmp.getChildren().add((Node) e1);
                        tmp.getChildren().add((Node) e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 AND Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_AND_Expr);
                        tmp.getChildren().add((Node) e1);
                        tmp.getChildren().add((Node) e2);
                        RESULT = tmp;
                        :}
						| Expr:e1 OR Expr:e2
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_OR_Expr);
                        tmp.getChildren().add((Node) e1);
                        tmp.getChildren().add((Node) e2);
                        RESULT = tmp;
                        :}
						| NOT Expr:e
                        {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.NOT_Expr);
                        tmp.getChildren().add((Node) e);
                        RESULT = tmp;
                        :}
						| READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.READINTEGER_OPENPARENTHESIS_CLOSEPARENTHESIS);
                        RESULT = tmp;
                        :}
						| READLINE OPENPARENTHESIS CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.READLINE_OPENPARENTHESIS_CLOSEPARENTHESIS);
                        RESULT = tmp;
                        :}
						| NEW IDENTIFIER:id
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.NEW_IDENTIFIER);
                        Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                        idNode.setValue(id);
                        tmp.getChildren().add(idNode);
                        RESULT = tmp;
                        :}
						| NEWARRAY OPENPARENTHESIS Expr:e COMMA Type:t CLOSEPARENTHESIS
                        {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.NEWARRAY_OPENPARENTHESIS_Expr_COMMA_Type_CLOSEPARENTHESIS);
                        tmp.getChildren().add((Node)e);
                        tmp.getChildren().add((Node)t);
                        RESULT = tmp;
                        :}
						| ITOD OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.ITOD_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                        tmp.getChildren().add((Node)e);
                        RESULT = tmp;
                        :}
						| DTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.DTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                        tmp.getChildren().add((Node)e);
                        RESULT = tmp;
                        :}
						| ITOB OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
                        {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.ITOB_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                        tmp.getChildren().add((Node)e);
                        RESULT = tmp;
                        :}
                        | BTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
                        {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.BTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                        tmp.getChildren().add((Node)e);
                        RESULT = tmp;
                        :};

LValue ::=              IDENTIFIER:id
						{:  Node tmp = new Node(LeftHand.LValue, ProductionRule.IDENTIFIER);
                         Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                         idNode.setValue(id);
                         tmp.getChildren().add(idNode);
                         RESULT = tmp;
                        :}
						| Expr:e DOT IDENTIFIER:id
                        {:  Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_DOT_IDENTIFIER);
                          Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                          idNode.setValue(id);
                          tmp.getChildren().add((Node)e);
                          tmp.getChildren().add(idNode);
                          RESULT = tmp;
                        :}
						| Expr:e1 OPENBRACKET Expr:e2 CLOSEBRACKET
                        {:  Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_OPENBRACKET_Expr_CLOSEBRACKET);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						;

Call ::=                IDENTIFIER:functionID OPENPARENTHESIS Actuals:a CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Call, ProductionRule.IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS);
                         Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                         id.setValue(functionID);
                         tmp.getChildren().add(id);
                         tmp.getChildren().add((Node)a);
                         RESULT = tmp;
                        :}
						| Expr:e DOT IDENTIFIER:id OPENPARENTHESIS Actuals:a CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Call, ProductionRule.Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS);
                         Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                         idNode.setValue(id);
                         tmp.getChildren().add((Node)e);
                         tmp.getChildren().add(idNode);
                         tmp.getChildren().add((Node)a);
                         RESULT = tmp;
                        :}
						;

Actuals ::=             Expr:e ActualsCommaExpr
                        {:  Node tmp = new Node(LeftHand.Actuals, ProductionRule.Expr_ActualsCommaExpr);
                          tmp.getChildren().add((Node)e);
                          RESULT = tmp;
                          //todo
                        :}
						| /*epsilon*/
						{:  Node tmp = new Node(LeftHand.Actuals, ProductionRule.Expr_ActualsCommaExpr);
                            RESULT = tmp;
                        :}
						;

ActualsCommaExpr ::=    COMMA Expr:e ActualsCommaExpr
						{:  Node tmp = new Node(LeftHand.ActualsCommaExpr, ProductionRule.Expr_ActualsCommaExpr);
                          tmp.getChildren().add((Node)e);
                          RESULT = tmp;
                          //todo
                        :}
						| /*epsilon*/
						{:  Node tmp = new Node(LeftHand.ActualsCommaExpr, ProductionRule.EPSILON);
                            RESULT = tmp;
                        :}
						;

Constant ::=            DECIMAL:d
						{: Node tmp = new Node(LeftHand.Constant, ProductionRule.DECIMAL);
                           Node id = new Node(LeftHand.DECIMAL, ProductionRule.TERMINAL);
                           id.setValue(d);
                           tmp.getChildren().add(id);
                           RESULT = tmp;
                        :}
						| FLOATINGPOINT:f
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.FLOATINGPOINT);
                             Node id = new Node(LeftHand.FLOATINGPOINT, ProductionRule.TERMINAL);
                             id.setValue(f);
                             tmp.getChildren().add(id);
                             RESULT = tmp;
                        :}
						| BOOLEANLITERAL:b
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.BOOLEANLITERAL);
                          Node id = new Node(LeftHand.BOOLEANLITERAL, ProductionRule.TERMINAL);
                          id.setValue(b);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
                        :}
						| STRINGLITERAL:s
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.STRINGLITERAL);
                         Node id = new Node(LeftHand.STRINGLITERAL, ProductionRule.TERMINAL);
                         id.setValue(s);
                         tmp.getChildren().add(id);
                         RESULT = tmp;
                        :}
						| NULL:n
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.NULL);
                          Node id = new Node(LeftHand.NULL, ProductionRule.TERMINAL);
                          id.setValue(n);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
                        :}
						;