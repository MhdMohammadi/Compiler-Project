import java_cup.runtime.*;


parser code  {:
    public static Node root;

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};
// defining terminals here
// arithmetic operators
terminal        PLUS, MINUS, MULTIPLY, DIVIDE, MOD, UMINUS,
				LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL, NOTEQUAL;
// logical operators
terminal	    AND, OR, NOT;
// dot
terminal        DOT;
// types
terminal        String INT, DOUBLE, BOOL, STRING;

// literals
terminal        String DECIMAL;
terminal        String FLOATINGPOINT;
terminal        String BOOLEANLITERAL;
terminal        String STRINGLITERAL;
terminal        NULL;

// signs
terminal		OPENBRACKET, CLOSEBRACKET, OPENCLOSEBRACKET, WS, OPENPARENTHESIS,
				CLOSEPARENTHESIS, OPENCURLYBRACES, CLOSECURLYBRACES;
// keywords
terminal        READINTEGER, READLINE, NEW, NEWARRAY, ITOD, DTOI, ITOB, BTOI,
				VOID, CLASS, INTERFACE,
				EXTENDS, IMPLEMENTS, COMMA, SEMICOLON, PRIVATE, PROTECTED, PUBLIC, IF, ELSE, WHILE, FOR, RETURN,
				BREAK, CONTINUE, PRINT, ASSIGN, THIS;
terminal        String IDENTIFIER;

// defining nonterminals
nonterminal     Program, DeclStar, Decl, VariableDecl, Variable, FunctionDecl, Formals, CommaVariables,
				ClassDecl, ClassDeclExtends, ClassDeclImplements, CommaIdentifiers, FieldStar, Field,
				AccessMode, InterfaceDecl, PrototypeStar, Prototype, StmtBlock, InsideStmtBlock, VariableDeclStar, StmtStar,
				Stmt, ExprPrime, IfStmt, ElsePrime, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt, PrintStmt,
				PrintCommaExpr, ActualsCommaExpr, Actuals;
// non-terminals with type
nonterminal     Type;
nonterminal     LValue;
nonterminal     Expr;
nonterminal     Constant;
nonterminal     Call;

// defining precedences
precedence left     ELSE;
precedence right    ASSIGN;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, NOTEQUAL;
precedence left     LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left     PLUS, MINUS;
precedence left     MULTIPLY, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     DOT, OPENBRACKET;
precedence left     OPENPARENTHESIS;

start with Program;

Program ::=             Decl DeclStar;

DeclStar ::=            Decl DeclStar
						| /*epsilon*/
						;

Decl ::=                VariableDecl
						| FunctionDecl
						| ClassDecl
						| InterfaceDecl
						;

VariableDecl ::=        Variable SEMICOLON;

Variable ::=            Type:type IDENTIFIER:id
						;

Type ::=                INT
						| DOUBLE
						| BOOL
						| STRING
                        | IDENTIFIER:e
						| Type:t OPENCLOSEBRACKET
						;

FunctionDecl ::=        Type:t IDENTIFIER:name OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						| VOID IDENTIFIER:name OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						;

Formals ::=             Variable:v CommaVariables
						| /*epsilon*/
						;
CommaVariables ::=      COMMA Variable CommaVariables
						| /*epsilon*/
						;

ClassDecl ::=           CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements OPENCURLYBRACES FieldStar CLOSECURLYBRACES;
ClassDeclExtends ::=    EXTENDS IDENTIFIER
						| /*epsilon*/
						;
ClassDeclImplements ::= IMPLEMENTS IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
CommaIdentifiers ::=    COMMA IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
FieldStar ::=           Field FieldStar
						| /*epsilon*/
						;

Field ::=               AccessMode VariableDecl
						| AccessMode FunctionDecl
						;

AccessMode ::=          PRIVATE
						| PROTECTED
						| PUBLIC
						| /*epsilon*/
						;

InterfaceDecl ::=       INTERFACE IDENTIFIER OPENCURLYBRACES PrototypeStar CLOSECURLYBRACES;
PrototypeStar ::=       Prototype PrototypeStar
						| /*epsilon*/
						;

Prototype ::=           Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						;

StmtBlock ::=           OPENCURLYBRACES InsideStmtBlock CLOSECURLYBRACES;
InsideStmtBlock ::=     VariableDecl InsideStmtBlock
						| StmtStar
						;
StmtStar ::=            Stmt StmtStar
						| /*epsilon*/
						;

Stmt ::=                ExprPrime SEMICOLON
						| IfStmt
						| WhileStmt
						| ForStmt
						| BreakStmt
						| ContinueStmt
						| ReturnStmt
						| PrintStmt
						| StmtBlock
						;

ExprPrime ::=           Expr:e
						| /*epsilon*/
						;

IfStmt ::=              IF OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt ElsePrime
                        ;

ElsePrime ::=           ELSE Stmt:s
						| /*epsilon*/
                        ;


WhileStmt ::=           WHILE OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt:s;

ForStmt ::=             FOR OPENPARENTHESIS ExprPrime SEMICOLON Expr:e SEMICOLON ExprPrime CLOSEPARENTHESIS Stmt;

ReturnStmt ::=          RETURN ExprPrime:e SEMICOLON
						;

BreakStmt ::=           BREAK SEMICOLON;

ContinueStmt ::=        CONTINUE SEMICOLON;

PrintStmt ::=           PRINT OPENPARENTHESIS Expr:e PrintCommaExpr CLOSEPARENTHESIS SEMICOLON
						;

PrintCommaExpr ::=      COMMA Expr:e PrintCommaExpr
						|
						/*epsilon*/
						;

Expr ::=                LValue:lv ASSIGN Expr:e
						| Constant:c
						| LValue:lv
						| THIS
						| Call:c
						| OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| Expr:e1 PLUS Expr:e2
						| Expr:e1 MINUS Expr:e2
						| Expr:e1 MULTIPLY Expr:e2
						| Expr:e1 DIVIDE Expr:e2
						| Expr:e1 MOD Expr:e2
						| MINUS Expr:e %prec UMINUS
                        | Expr:e1 LESS Expr:e2
						| Expr:e1 LESSEQUAL Expr:e2
						| Expr:e1 GREATER Expr:e2
						| Expr:e1 GREATEREQUAL Expr:e2
						| Expr:e1 EQUAL Expr:e2
						| Expr:e1 NOTEQUAL Expr:e2
						| Expr:e1 AND Expr:e2
						| Expr:e1 OR Expr:e2
						| NOT Expr:e
						| READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS
						| READLINE OPENPARENTHESIS CLOSEPARENTHESIS
						| NEW IDENTIFIER
						| NEWARRAY OPENPARENTHESIS Expr:e COMMA Type:t CLOSEPARENTHESIS
						| ITOD OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| DTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| ITOB OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| BTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						;

LValue ::=              IDENTIFIER:id
						{:  Node tmp = new Node(LeftHand.LValue, ProductionRule.IDENTIFIER);
                         Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                         idNode.setValue(id);
                         tmp.getChildren().add(idNode);
                         RESULT = tmp;
                        :}
						| Expr:e DOT IDENTIFIER:id
                        {:  Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_DOT_IDENTIFIER);
                          Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                          idNode.setValue(id);
                          tmp.getChildren().add((Node)e);
                          tmp.getChildren().add(idNode);
                          RESULT = tmp;
                        :}
						| Expr:e1 OPENBRACKET Expr:e2 CLOSEBRACKET
                        {:  Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_OPENBRACKET_Expr_CLOSEBRACKET);
                        tmp.getChildren().add((Node)e1);
                        tmp.getChildren().add((Node)e2);
                        RESULT = tmp;
                        :}
						;

Call ::=                IDENTIFIER:functionID OPENPARENTHESIS Actuals:a CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Call, ProductionRule.IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS);
                         Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                         id.setValue(functionID);
                         tmp.getChildren().add(id);
                         tmp.getChildren().add((Node)a);
                         RESULT = tmp;
                        :}
						| Expr:e DOT IDENTIFIER:id OPENPARENTHESIS Actuals:a CLOSEPARENTHESIS
						{:  Node tmp = new Node(LeftHand.Call, ProductionRule.Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS);
                         Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                         idNode.setValue(id);
                         tmp.getChildren().add((Node)e);
                         tmp.getChildren().add(idNode);
                         tmp.getChildren().add((Node)a);
                         RESULT = tmp;
                        :}
						;

Actuals ::=             Expr:e ActualsCommaExpr
                        {:  Node tmp = new Node(LeftHand.Actuals, ProductionRule.Expr_ActualsCommaExpr);
                          tmp.getChildren().add((Node)e);
                          RESULT = tmp;
                          //todo
                        :}
						| /*epsilon*/
						{:  Node tmp = new Node(LeftHand.Actuals, ProductionRule.Expr_ActualsCommaExpr);
                            RESULT = tmp;
                        :}
						;

ActualsCommaExpr ::=    COMMA Expr:e ActualsCommaExpr
						{:  Node tmp = new Node(LeftHand.ActualsCommaExpr, ProductionRule.Expr_ActualsCommaExpr);
                          tmp.getChildren().add((Node)e);
                          RESULT = tmp;
                          //todo
                        :}
						| /*epsilon*/
						{:  Node tmp = new Node(LeftHand.ActualsCommaExpr, ProductionRule.EPSILON);
                            RESULT = tmp;
                        :}
						;

Constant ::=            DECIMAL:d
						{: Node tmp = new Node(LeftHand.Constant, ProductionRule.DECIMAL);
                           Node id = new Node(LeftHand.DECIMAL, ProductionRule.TERMINAL);
                           id.setValue(d);
                           tmp.getChildren().add(id);
                           RESULT = tmp;
                        :}
						| FLOATINGPOINT:f
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.FLOATINGPOINT);
                             Node id = new Node(LeftHand.FLOATINGPOINT, ProductionRule.TERMINAL);
                             id.setValue(f);
                             tmp.getChildren().add(id);
                             RESULT = tmp;
                        :}
						| BOOLEANLITERAL:b
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.BOOLEANLITERAL);
                          Node id = new Node(LeftHand.BOOLEANLITERAL, ProductionRule.TERMINAL);
                          id.setValue(b);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
                        :}
						| STRINGLITERAL:s
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.STRINGLITERAL);
                         Node id = new Node(LeftHand.STRINGLITERAL, ProductionRule.TERMINAL);
                         id.setValue(s);
                         tmp.getChildren().add(id);
                         RESULT = tmp;
                        :}
						| NULL:n
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.NULL);
                          Node id = new Node(LeftHand.NULL, ProductionRule.TERMINAL);
                          id.setValue(n);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
                        :}
						;