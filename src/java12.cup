import java_cup.runtime.*;


/* August 1999 - modified by Gerwin Klein <lsf@jflex.de>
                 to interface with JFlex scanners,
                 allows empty semicolon in class decls.
  
  changed productions:

  class_member_declaration ::=
	  	field_declaration
  	|	method_declaration
    [..]
  	|	interface_declaration
    | SEMICOLON
  	;

  interface_member_declaration ::=
  		constant_declaration
	  |	abstract_method_declaration
  	|	class_declaration
  	|	interface_declaration
    | SEMICOLON
	  ;

*/


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/

parser code  {:
    public static Node root;

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal STRING, VOID, INT, DOUBLE, BOOL;
terminal CLASS;
terminal INTERFACE;
terminal NULL;
terminal THIS;
terminal EXTENDS;
terminal IMPLEMENTS;
terminal FOR;
terminal WHILE;
terminal IF, ELSE;
terminal RETURN;
terminal BREAK;
terminal CONTINUE;
terminal NEW;
terminal NEWARRAY;
terminal PRINT;
terminal READINTEGER;
terminal READLINE;
terminal DTOI;
terminal ITOB;
terminal ITOD;
terminal BTOI;
terminal PRIVATE, PUBLIC, PROTECTED;
terminal TRUE, FALSE;
terminal GT, LT, GTEQ, LTEQ;
terminal QUESTION;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, DIV, COMP, NOT, MOD;
terminal DOT;
terminal LBRACK, RBRACK;
terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, EQ, MULT, SEMICOLON, COLON;
terminal UNDEFINED_TOKEN;


terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number DOUBLE_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.Boolean BOOLEAN_LITERAL;


//in ja benevisiiiiid
nonterminal Program;
nonterminal Decl;
nonterminal VariableDecl;
nonterminal Variable;
nonterminal Type;
nonterminal FunctionDecl;
nonterminal Formals;
nonterminal ClassDecl;
nonterminal Field;


nonterminal AccessMode;
nonterminal InterfaceDecl;
nonterminal Prototype;
nonterminal StmtBlock;
nonterminal Stmt;
nonterminal IfStmt;
nonterminal WhileStmt;
nonterminal ForStmt;

nonterminal ReturnStmt;
nonterminal BreakStmt;
nonterminal ContinueStmt;
nonterminal PrintStmt;
nonterminal Expr;
nonterminal LValue;
nonterminal Call;
nonterminal Actuals;
nonterminal Constant;

nonterminal DeclPlus;
nonterminal VariablePlus;
nonterminal ExtendStmt;
nonterminal ImplementsStmt;
nonterminal IdentifierImplementsStmt;
nonterminal FieldStar;
nonterminal Prototype_star;
nonterminal VariableDecl_star;
nonterminal Stmt_star;
nonterminal Expr_Stmt;
nonterminal else_Stmt;
nonterminal Expr_plus;


precedence left ELSE;
precedence right EQ;
precedence left OROR;
precedence left ANDAND;
precedence left EQEQ, NOTEQ;
precedence left GT, GTEQ, LT, LTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOT, MINUS;
precedence left LBRACK, DOT;
//precedence left IDENTIFIER;

start with Program;

Program ::= DeclPlus:d {: Node tmp = new Node(LeftHand.Program, ProductionRule.DeclPlus); tmp.getChildren().add((Node) d);
                        RESULT = tmp; root = tmp;:};
DeclPlus ::= Decl | Decl DeclPlus;
Decl ::= VariableDecl | FunctionDecl | ClassDecl | InterfaceDecl;
VariableDecl ::= Variable SEMICOLON;
Variable ::= Type:t IDENTIFIER:i{:
    Node tmp = new Node(NonTerminal.Variable, ProductionRule.Type_IDENTIFIER);
    tmp.getChildren().add((Node) t);

    Node id = new Node(Node.IDENTIFIER, ProductionRule.IDENTIFIER);
    id.setValue(i);
    tmp.getChildren().add(id);
    RESULT = tmp;
:};
Type ::= Type LBRACK RBRACK | IDENTIFIER %prec MULT | INT | DOUBLE | STRING | BOOL ;
FunctionDecl ::= Type IDENTIFIER  LPAREN Formals RPAREN StmtBlock | VOID IDENTIFIER LPAREN Formals RPAREN StmtBlock;
VariablePlus ::= Variable | Variable COMMA VariablePlus;
Formals ::= VariablePlus | ;
ExtendStmt ::= EXTENDS IDENTIFIER |;
ImplementsStmt ::= IMPLEMENTS IdentifierImplementsStmt|;
IdentifierImplementsStmt ::= IDENTIFIER COMMA IdentifierImplementsStmt | IDENTIFIER;
FieldStar ::= Field FieldStar |;
Field ::= AccessMode VariableDecl | AccessMode FunctionDecl;
ClassDecl ::= CLASS IDENTIFIER ExtendStmt ImplementsStmt LBRACE FieldStar RBRACE;

AccessMode ::= PRIVATE
{: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.TERMINAL);
RESULT = tmp;:} |
PROTECTED {: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.TERMINAL);
RESULT = tmp;:} |
PUBLIC {: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.TERMINAL);
RESULT = tmp;:} |
{: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.NOTHING);
RESULT = tmp;:} ;
InterfaceDecl ::= INTERFACE IDENTIFIER:i LBRACE Prototype_star:ps RBRACE
{: Node tmp = new Node(LeftHand.InterfaceDecl, ProductionRule.INTERFACE_IDENTIFIER_LBRACE_Prototype_star_RBRACE);
tmp.getChildren().add((Node) ps);
Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
id.setValue(i);
tmp.getChildren().add(id);
Node in = new Node(LeftHand.INTERFACE, ProductionRule.TERMINAL);
tmp.getChildren().add(in);
RESULT = tmp;:};
Prototype_star ::=  Prototype:p Prototype_star
{: Node tmp = new Node(LeftHand.Prototype_star, ProductionRule.Prototype_Prototype_star);
tmp.getChildren().add((Node) p);
RESULT = tmp;:} |
{: Node tmp = new Node(LeftHand.Prototype_star, ProductionRule.NOTHING);
RESULT = tmp;:};
Prototype ::= Type:t IDENTIFIER:i LPAREN Formals:f RPAREN SEMICOLON
{: Node tmp = new Node(LeftHand.Prototype, ProductionRule.Type_IDENTIFIER_LPAREN_Formals_RPAREN_SEMICOLON);
tmp.getChildren().add((Node) t);
Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
id.setValue(i);
tmp.getChildren().add(id);
tmp.getChildren().add((Node) f);
RESULT = tmp;:} | VOID IDENTIFIER:i LPAREN Formals:f RPAREN SEMICOLON
{: Node tmp = new Node(LeftHand.Prototype, ProductionRule.VOID_IDENTIFIER_LPAREN_Formals_RPAREN_SEMICOLON);
tmp.getChildren().add((Node) f);
Node vo = new Node(LeftHand.VOID, ProductionRule.TERMINAL);
tmp.getChildren().add(vo);
Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
id.setValue(i);
tmp.getChildren().add(id);
RESULT = tmp;:};
StmtBlock ::= LBRACE VariableDecl_star:vs Stmt_star:ss RBRACE
{: Node tmp = new Node(LeftHand.StmtBlock, ProductionRule.LBRACE_VariableDecl_star_Stmt_star_RBRACE);
tmp.getChildren().add((Node) vs);
tmp.getChildren().add((Node) ss);
Node lb = new Node(LeftHand.LBRACE, ProductionRule.TERMINAL);
tmp.getChildren().add(lb);
Node rb = new Node(LeftHand.RBRACE, ProductionRule.TERMINAL);
tmp.getChildren().add(rb);
RESULT = tmp;:};
VariableDecl_star ::= VariableDecl:v VariableDecl_star
 {: Node tmp = new Node(LeftHand.VariableDecl_star, ProductionRule.);
 tmp.getChildren().add((Node) v);
 RESULT = tmp;:} | %prec PLUS;
Stmt_star ::= Stmt:s Stmt_star
{: Node tmp = new Node(LeftHand.Stmt_star, ProductionRule.Stmt_Stmt_star);
tmp.getChildren().add((Node) s);
RESULT = tmp;:} |
{: Node tmp = new Node(LeftHand.Stmt_star, ProductionRule.NOTHING);
RESULT = tmp;:};
Stmt ::=  Expr_Stmt:es  SEMICOLON
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.Expr_Stmt_SEMICOLON);
tmp.getChildren().add((Node) es);
Node s = new Node(LeftHand.SEMICOLON, ProductionRule.TERMINAL);
tmp.getChildren().add(s);
RESULT = tmp;:} | IfStmt:i
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.IfStmt);
tmp.getChildren().add((Node) i);
RESULT = tmp;:}| WhileStmt:w
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.WhileStmt);
tmp.getChildren().add((Node) w);
RESULT = tmp;:} | ForStmt:f
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ForStmt);
tmp.getChildren().add((Node) f);
RESULT = tmp;:} | BreakStmt:b
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.BreakStmt);
tmp.getChildren().add((Node) b);
RESULT = tmp;:} | ContinueStmt:c
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ContinueStmt);
tmp.getChildren().add((Node) c);
RESULT = tmp;:} | ReturnStmt:r
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ReturnStmt);
tmp.getChildren().add((Node) r);
RESULT = tmp;:} | PrintStmt:p
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.PrintStmt);
tmp.getChildren().add((Node) p);
RESULT = tmp;:}| StmtBlock:s
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.StmtBlock);
tmp.getChildren().add((Node) s);
RESULT = tmp;:};
Expr_Stmt ::= Expr:e
{: Node tmp = new Node(LeftHand.Expr_Stmt, ProductionRule.Expr);
tmp.getChildren().add((Node) e);
RESULT = tmp;:} |
{: Node tmp = new Node(LeftHand.Prototype_star, ProductionRule.NOTHING);
RESULT = tmp;:};
IfStmt ::= IF LPAREN Expr:e RPAREN Stmt:s else_Stmt:es
{: Node tmp = new Node(LeftHand.IfStmt, ProductionRule.IF_LPAREN_Expr_RPAREN_Stmt_else_Stmt);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) s);
tmp.getChildren().add((Node) es);
Node i = new Node(LeftHand.IF, ProductionRule.TERMINAL);
tmp.getChildren().add(i);
RESULT = tmp;:};
else_Stmt ::= ELSE Stmt:s
{: Node tmp = new Node(LeftHand.else_Stmt, ProductionRule.ELSE_Stmt);
tmp.getChildren().add((Node) s);
Node e = new Node(LeftHand.ELSE, ProductionRule.TERMINAL);
tmp.getChildren().add(e);
RESULT = tmp;:}|
{: Node tmp = new Node(LeftHand.else_Stmt, ProductionRule.NOTHING);
RESULT = tmp;:};
WhileStmt ::= WHILE LPAREN Expr:e RPAREN Stmt:s
{: Node tmp = new Node(LeftHand.WhileStmt, ProductionRule.WHILE_LPAREN_Expr_RPAREN_Stmt);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) s);
Node w = new Node(LeftHand.WHILE, ProductionRule.TERMINAL);
tmp.getChildren().add(w);
RESULT = tmp;:};
ForStmt ::= FOR LPAREN  Expr_Stmt:es  SEMICOLON Expr:e SEMICOLON  Expr_Stmt:es1  RPAREN Stmt:s
{: Node tmp = new Node(LeftHand.ForStmt, ProductionRule.FOR_LPAREN_Expr_Stmt_SEMICOLON_Expr_SEMICOLON_Expr_Stmt_RPAREN_Stmt);
tmp.getChildren().add((Node) es);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) es1);
tmp.getChildren().add((Node) s);
Node f = new Node(LeftHand.FOR, ProductionRule.TERMINAL);
tmp.getChildren().add(f);
RESULT = tmp;:};

ReturnStmt ::= RETURN Expr:e SEMICOLON
{: Node tmp = new Node(LeftHand.ReturnStmt, ProductionRule.RETURN_Expr_SEMICOLON);
tmp.getChildren().add((Node) e);
Node r = new Node(LeftHand.RETURN, ProductionRule.TERMINAL);
tmp.getChildren().add(r);
RESULT = tmp;:}| RETURN SEMICOLON
{: Node tmp = new Node(LeftHand.ReturnStmt, ProductionRule.RETURN_SEMICOLON);
Node r = new Node(LeftHand.RETURN, ProductionRule.TERMINAL);
tmp.getChildren().add(r);
RESULT = tmp;:};
BreakStmt ::= BREAK SEMICOLON
{: Node tmp = new Node(LeftHand.BreakStmt, ProductionRule.BREAK-SEMICOLON);
Node b = new Node(LeftHand.BREAK, ProductionRule.TERMINAL);
tmp.getChildren().add(b);
RESULT = tmp;:};
ContinueStmt ::= CONTINUE SEMICOLON
{: Node tmp = new Node(LeftHand.ContinueStmt, ProductionRule.CONTINUE_SEMICOLON);
Node c = new Node(LeftHand.CONTINUE, ProductionRule.TERMINAL);
tmp.getChildren().add(c);
RESULT = tmp;:};
//+ ro doros kon
PrintStmt ::= PRINT LPAREN Expr_plus:ep RPAREN SEMICOLON
{: Node tmp = new Node(LeftHand.PrintStmt, ProductionRule.PRINT_LPAREN_Expr_plus_RPAREN_SEMICOLON);
tmp.getChildren().add((Node) ep);
Node p = new Node(LeftHand.PRINT, ProductionRule.TERMINAL);
tmp.getChildren().add(p);
RESULT = tmp;:};
Expr_plus ::= Expr:e
{: Node tmp = new Node(LeftHand.Expr_plus, ProductionRule.Expr);
tmp.getChildren().add((Node) e);
RESULT = tmp;:}| Expr:e COMMA Expr_plus:ep
{: Node tmp = new Node(LeftHand.Expr_plus, ProductionRule.Expr_COMMA_Expr_plus);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) ep);
Node c = new Node(LeftHand.COMMA, ProductionRule.TERMINAL);
tmp.getChildren().add(c);
RESULT = tmp;:};

Expr ::= LValue EQ Expr | Constant | LValue | THIS | Call | LPAREN Expr RPAREN | Expr PLUS Expr |
 Expr MINUS Expr | Expr MULT Expr | Expr DIV Expr | Expr MOD Expr | MINUS Expr | Expr LT Expr | Expr LTEQ Expr |
Expr GT Expr | Expr GTEQ Expr | Expr EQEQ Expr | Expr NOTEQ Expr | Expr ANDAND Expr | Expr OROR Expr |
  NOT Expr | READINTEGER LPAREN RPAREN | READLINE LPAREN RPAREN | NEW IDENTIFIER | NEWARRAY LPAREN Expr COMMA Type RPAREN |
ITOD LPAREN Expr RPAREN | DTOI LPAREN Expr RPAREN | ITOB LPAREN Expr RPAREN | BTOI LPAREN Expr RPAREN;
LValue ::= IDENTIFIER | Expr DOT IDENTIFIER | Expr LBRACK Expr RBRACK;
Call ::= IDENTIFIER LPAREN Actuals RPAREN | Expr DOT IDENTIFIER LPAREN Actuals RPAREN;
Actuals ::= Expr_plus | ;
Constant ::= INTEGER_LITERAL:i {:  Node tmp = new Node(NonTerminal.Constant, ProductionRule.INTEGRAL_LITERAL);
                                   Node id = new Node(Nonterminal.INTE, ProductionRule.IDENTIFIER);
                                   id.setValue(i);
                                   tmp.getChildren().add(id);
                                   RESULT = tmp;
:}|
 DOUBLE_LITERAL | BOOLEAN_LITERAL | STRING_LITERAL | NULL;

