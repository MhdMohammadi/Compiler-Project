import java_cup.runtime.*;


parser code  {:
    public static Node root;

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};
// defining terminals here
// arithmetic operators
terminal        PLUS, MINUS, MULTIPLY, DIVIDE, MOD, UMINUS,
				LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL, NOTEQUAL;
// logical operators
terminal	    AND, OR, NOT;
// dot
terminal        DOT;
// types
terminal        String INT, DOUBLE, BOOL, STRING;

// literals
terminal        String DECIMAL;
terminal        String FLOATINGPOINT;
terminal        String BOOLEANLITERAL;
terminal        String STRINGLITERAL;
terminal        NULL;

// signs
terminal		OPENBRACKET, CLOSEBRACKET, OPENCLOSEBRACKET, WS, OPENPARENTHESIS,
				CLOSEPARENTHESIS, OPENCURLYBRACES, CLOSECURLYBRACES;
// keywords
terminal        READINTEGER, READLINE, NEW, NEWARRAY, ITOD, DTOI, ITOB, BTOI,
				VOID, CLASS, INTERFACE,
				EXTENDS, IMPLEMENTS, COMMA, SEMICOLON, PRIVATE, PROTECTED, PUBLIC, IF, ELSE, WHILE, FOR, RETURN,
				BREAK, CONTINUE, PRINT, ASSIGN, THIS;
terminal        String IDENTIFIER;

// defining nonterminals
nonterminal     Program, DeclStar, Decl, VariableDecl, Variable, FunctionDecl, Formals, CommaVariables,
				ClassDecl, ClassDeclExtends, ClassDeclImplements, CommaIdentifiers, FieldStar, Field,
				AccessMode, InterfaceDecl, PrototypeStar, Prototype, StmtBlock, InsideStmtBlock, VariableDeclStar, StmtStar,
				Stmt, ExprPrime, IfStmt, ElsePrime, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt, PrintStmt,
				PrintCommaExpr, ActualsCommaExpr, Actuals;
// non-terminals with type
nonterminal     Type;
nonterminal     LValue;
nonterminal     Expr;
nonterminal     Constant;
nonterminal     Call;

// defining precedences
precedence left     ELSE;
precedence right    ASSIGN;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, NOTEQUAL;
precedence left     LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left     PLUS, MINUS;
precedence left     MULTIPLY, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     DOT, OPENBRACKET;
precedence left     OPENPARENTHESIS;

start with Program;

Program ::=             Decl:d1 DeclStar:d2{:
    Node tmp = new Node(LeftHand.Program, ProductionRule.Decl_DeclStar);
    tmp.getChildren().add((Node) d1);
    tmp.getChildren().add((Node) d2);
    tmp.getDefinedVariables().addAll(((Node)d1).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)d2).getDefinedVariables());
    RESULT = tmp; root = tmp;
:};

DeclStar ::=            Decl:d1 DeclStar:d2{:
    Node tmp = new Node(LeftHand.DeclStar, ProductionRule.Decl_DeclStar);
    tmp.getChildren().add((Node)d1);
    tmp.getChildren().add((Node)d2);
    tmp.getDefinedVariables().addAll(((Node)d1).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)d2).getDefinedVariables());
    RESULT = tmp;
:}
						| {:
    Node tmp = new Node(LeftHand.DeclStar, ProductionRule.EPSILON);
    RESULT = tmp;
:}/*epsilon*/
;

Decl ::=                VariableDecl:v{:
    Node tmp = new Node(LeftHand.Decl, ProductionRule.VariableDecl);
    tmp.getChildren().add((Node)v);
    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
    RESULT = tmp;
:}
						| FunctionDecl:f{:
    Node tmp = new Node(LeftHand.Decl, ProductionRule.FunctionDecl);
    tmp.getChildren().add((Node)f);
    RESULT = tmp;
:}
						| ClassDecl:c{:
    Node tmp = new Node(LeftHand.Decl, ProductionRule.ClassDecl);
    tmp.getChildren().add((Node)c);
    RESULT = tmp;
						:}
						| InterfaceDecl:i{:
    Node tmp = new Node(LeftHand.Decl, ProductionRule.InterfaceDecl);
    tmp.getChildren().add((Node)i);
    RESULT = tmp;
						:}
						;

VariableDecl ::=        Variable:v SEMICOLON{:
    Node tmp = new Node(LeftHand.VariableDecl, ProductionRule.Variable_SEMICOLON);
    tmp.getChildren().add((Node)v);
    RESULT = tmp;
:};

Variable ::=            Type:t IDENTIFIER:i{:
    Node tmp = new Node(LeftHand.Variable, ProductionRule.Type_IDENTIFIER);
    tmp.getChildren().add((Node) t);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i);
    tmp.getChildren().add(id);
    Variable variable = new Variable();
    variable.setName(i);
    tmp.getDefinedVariables().add(variable);
    RESULT = tmp;
:}
						;

Type ::=                INT:i{:
     Node tmp = new Node(LeftHand.Type, ProductionRule.INT);
     Node in = new Node(LeftHand.INT, ProductionRule.TERMINAL);
     in.setValue(i);
     tmp.getChildren().add(in);
     tmp.setTypeName("int");
     RESULT = tmp;
:}
						| DOUBLE:d{:
     Node tmp = new Node(LeftHand.Type, ProductionRule.DOUBLE);
     Node doub = new Node(LeftHand.DOUBLE, ProductionRule.TERMINAL);
     doub.setValue(d);
     tmp.getChildren().add(doub);
     tmp.setTypeName("double");
     RESULT = tmp;
:}
						| BOOL:b{:
     Node tmp = new Node(LeftHand.Type, ProductionRule.BOOL);
     Node bo = new Node(LeftHand.BOOL, ProductionRule.TERMINAL);
     bo.setValue(b);
     tmp.getChildren().add(bo);
     tmp.setTypeName("boolean");
     RESULT = tmp;
:}
						| STRING:s{:
     Node tmp = new Node(LeftHand.Type, ProductionRule.STRING);
     Node str = new Node(LeftHand.STRING, ProductionRule.TERMINAL);
     str.setValue(s);
     tmp.getChildren().add(str);
     tmp.setTypeName("string");
     RESULT = tmp;
:}
                        | IDENTIFIER:i{:
    Node tmp = new Node(LeftHand.Type, ProductionRule.IDENTIFIER);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i);
    tmp.getChildren().add(id);
    tmp.setTypeName(i);
    RESULT = tmp;
:}
						| Type:t OPENCLOSEBRACKET{:
    Node tmp = new Node(LeftHand.Type, ProductionRule.Type_OPENCLOSEBRACKET);
    tmp.getChildren().add((Node)t);
    tmp.setTypeName(((Node)t).getTypeName());
    tmp.setArrayDegree(((Node)t).getArrayDegree() + 1);
    RESULT = tmp;
						:}
						;

FunctionDecl ::=        Type:t IDENTIFIER:i OPENPARENTHESIS Formals:f CLOSEPARENTHESIS StmtBlock:s{:
    Node tmp = new Node(LeftHand.FunctionDecl, ProductionRule.Type_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock);
    tmp.getChildren().add((Node)t);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i);
    tmp.getChildren().add(id);
    tmp.getChildren().add((Node) f);
    tmp.getChildren().add((Node) s);
    tmp.getDefinedVariables().addAll(((Node)f).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)s).getDefinedVariables());
    RESULT = tmp;
:}
						| VOID IDENTIFIER:i OPENPARENTHESIS Formals:f CLOSEPARENTHESIS StmtBlock:s{:
    Node tmp = new Node(LeftHand.FunctionDecl, ProductionRule.VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i);
    tmp.getChildren().add(id);
    tmp.getChildren().add((Node)f);
    tmp.getChildren().add((Node)s);
    tmp.getDefinedVariables().addAll(((Node)f).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)s).getDefinedVariables());
    RESULT = tmp;
:}
						;

Formals ::=             Variable:v CommaVariables:c{:
    Node tmp = new Node(LeftHand.Formals, ProductionRule.Variable_CommaVariables);
    tmp.getChildren().add((Node)v);
    tmp.getChildren().add((Node)c);
    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)c).getDefinedVariables());
    RESULT = tmp;
:}
						| {:
    Node tmp = new Node(LeftHand.Formals, ProductionRule.EPSILON);
    RESULT = tmp;
:}/*epsilon*/
;
CommaVariables ::=      COMMA Variable:v CommaVariables:c{:
    Node tmp = new Node(LeftHand.CommaVariables, ProductionRule.COMMA_Variable_CommaVariables;
    tmp.getChildren().add((Node)v);
    tmp.getChildren().add((Node)c);
    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)c).getDefinedVariables());
    RESULT = tmp;
:}
						| /*epsilon*/{:
    Node tmp = new Node(LeftHand.CommaVariables, ProductionRule.EPSILON);
    RESULT = tmp;
:}
;

ClassDecl ::=           CLASS IDENTIFIER:i ClassDeclExtends:c1 ClassDeclImplements:c2 OPENCURLYBRACES FieldStar:f CLOSECURLYBRACES{:
    Node tmp = new Node(LeftHand.ClassDecl, ProductionRule.CLASS_IDENTIFIER_ClassDeclExtends_ClassDeclImplements_OPENCURLYBRACES_FieldStar_CLOSECURLYBRACES);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i1);
    tmp.getChildren().add(id);
    tmp.getChildren().add((Node)c1);
    tmp.getChildren().add((Node)c2);
    tmp.getChildren().add((Node)f);
    if(((Node)e).getValue() != null)
        Type.createPreType(i1, (String)((Node)e).getValue());
    else
        Type.createPreType(i1, null);
    tmp.getDefinedVariables().addAll(((Node)f).getDefinedVariables());
    RESULT = tmp;
:};
ClassDeclExtends ::=    EXTENDS IDENTIFIER:i{:
    Node tmp = new Node(LeftHand.ClassDeclExtends, ProductionRule.EXTENDS_IDENTIFIER);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i);
    tmp.getChildren().add(id);
    tmp.setValue(i);
    RESULT = tmp;
:}
						| {:
    Node tmp = new Node(LeftHand.ClassDeclExtends, ProductionRule.EPSILON);
    tmp.setValue(null);
    RESULT = tmp;
:}/*epsilon*/
						;
ClassDeclImplements ::= IMPLEMENTS IDENTIFIER:i CommaIdentifiers:c{:
    Node tmp = new Node(LeftHand.ClassDeclImplements, ProductionRule.IMPLEMENTS_IDENTIFIER_CommaIdentifiers);
    tmp.getChildren().add((Node)i);
    tmp.getChildren().add((Node)c);
    RESULT = tmp;
:}
						| {:
    Node tmp = new Node(LeftHand.ClassDeclImplements, ProductionRule.EPSILON);
    RESULT = tmp;
:}/*epsilon*/
						;
CommaIdentifiers ::=    COMMA IDENTIFIER:i CommaIdentifiers:c{:
    Node tmp = new Node(LeftHand.CommaIdentifiers, ProductionRule.COMMA_IDENTIFIER_CommaIdentifiers);
    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
    id.setValue(i);
    tmp.getChildren().add(id);
    tmp.getChildren().add((Node)c);
    RESULT = tmp;
:}
						|{:
    Node tmp = new Node(LeftHand.CommaIdentifiers, ProductionRule.EPSILON);
    RESULT = tmp;
:} /*epsilon*/
						;
FieldStar ::=           Field:f1 FieldStar:f2{:
    Node tmp = new Node(LeftHand.FieldStar, ProductionRule.Field_FieldStar);
    tmp.getChildren().add((Node)f1);
    tmp.getChildren().add((Node)f2);
    tmp.getDefinedVariables().addAll(((Node)f1).getDefinedVariables());
    tmp.getDefinedVariables().addAll(((Node)f2).getDefinedVariables());
    RESULT = tmp;
:}
						| {:
    Node tmp = new Node(LeftHand.FieldStar, ProductionRule.EPSILON);
    RESULT = tmp;
:} /*epsilon*/
						;

Field ::=               AccessMode:a VariableDecl:v{:
    Node tmp = new Node(LeftHand.Field, ProductionRule.AccessMode_VariableDecl);
    tmp.getChildren().add((Node)a);
    tmp .getChildren().add((Node)v);
    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
    for(Variable variable: ((Node)v).getDefinedVariables()){
        variable.setAccessMode(((Node)a).getAccessMode());
    }
    RESULT = tmp;
:}
						| AccessMode:a FunctionDecl:f {:
    Node tmp = new Node(LeftHand.Field, ProductionRule.AccessMode_FunctionDecl);
    tmp.getChildren().add((Node)a);
    tmp.getChildren().add((Node)f);
    RESULT = tmp;
:}
						;

AccessMode ::=          PRIVATE
						| PROTECTED
						| PUBLIC
						| /*epsilon*/
						;

InterfaceDecl ::=       INTERFACE IDENTIFIER OPENCURLYBRACES PrototypeStar CLOSECURLYBRACES;
PrototypeStar ::=       Prototype PrototypeStar
						| /*epsilon*/
						;

Prototype ::=           Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						;

StmtBlock ::=           OPENCURLYBRACES InsideStmtBlock CLOSECURLYBRACES;
InsideStmtBlock ::=     VariableDecl InsideStmtBlock
						| StmtStar
						;
StmtStar ::=            Stmt StmtStar
						| /*epsilon*/
						;

Stmt ::=                ExprPrime SEMICOLON
						| IfStmt
						| WhileStmt
						| ForStmt
						| BreakStmt
						| ContinueStmt
						| ReturnStmt
						| PrintStmt
						| StmtBlock
						;

ExprPrime ::=           Expr:e
						| /*epsilon*/
						;

IfStmt ::=              IF OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt ElsePrime
                        ;

ElsePrime ::=           ELSE Stmt:s
						| /*epsilon*/
                        ;


WhileStmt ::=           WHILE OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt:s;

ForStmt ::=             FOR OPENPARENTHESIS ExprPrime SEMICOLON Expr:e SEMICOLON ExprPrime CLOSEPARENTHESIS Stmt;

ReturnStmt ::=          RETURN ExprPrime:e SEMICOLON
						;

BreakStmt ::=           BREAK SEMICOLON;

ContinueStmt ::=        CONTINUE SEMICOLON;

PrintStmt ::=           PRINT OPENPARENTHESIS Expr:e PrintCommaExpr CLOSEPARENTHESIS SEMICOLON
						;

PrintCommaExpr ::=      COMMA Expr:e PrintCommaExpr
						|
						/*epsilon*/
						;

Expr ::=                LValue:lv ASSIGN Expr:e
						| Constant:c
						| LValue:lv
						| THIS
						| Call:c
						| OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| Expr:e1 PLUS Expr:e2
						| Expr:e1 MINUS Expr:e2
						| Expr:e1 MULTIPLY Expr:e2
						| Expr:e1 DIVIDE Expr:e2
						| Expr:e1 MOD Expr:e2
						| MINUS Expr:e %prec UMINUS
                        | Expr:e1 LESS Expr:e2
						| Expr:e1 LESSEQUAL Expr:e2
						| Expr:e1 GREATER Expr:e2
						| Expr:e1 GREATEREQUAL Expr:e2
						| Expr:e1 EQUAL Expr:e2
						| Expr:e1 NOTEQUAL Expr:e2
						| Expr:e1 AND Expr:e2
						| Expr:e1 OR Expr:e2
						| NOT Expr:e
						| READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS
						| READLINE OPENPARENTHESIS CLOSEPARENTHESIS
						| NEW IDENTIFIER
						| NEWARRAY OPENPARENTHESIS Expr:e COMMA Type:t CLOSEPARENTHESIS
						| ITOD OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| DTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| ITOB OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| BTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						;

LValue ::=              IDENTIFIER:id
						| Expr DOT IDENTIFIER
						| Expr:e1 OPENBRACKET Expr:e2 CLOSEBRACKET
						;

Call ::=                IDENTIFIER:functionID OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						| Expr:e DOT IDENTIFIER:id OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						;

Actuals ::=             Expr:e ActualsCommaExpr
						| /*epsilon*/
						;

ActualsCommaExpr ::=    COMMA Expr:e ActualsCommaExpr
						| /*epsilon*/
						;

Constant ::=            DECIMAL:d
						{: Node tmp = new Node(LeftHand.Constant, ProductionRule.DECIMAL);
                           Node id = new Node(LeftHand.DECIMAL, ProductionRule.TERMINAL);
                           id.setValue(d);
                           tmp.getChildren().add(id);
                           RESULT = tmp;
                        :}
						| FLOATINGPOINT:f
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.FLOATINGPOINT);
                             Node id = new Node(LeftHand.FLOATINGPOINT, ProductionRule.TERMINAL);
                             id.setValue(f);
                             tmp.getChildren().add(id);
                             RESULT = tmp;
                        :}
						| BOOLEANLITERAL:b
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.BOOLEAN_LITERAL);
                          Node id = new Node(LeftHand.BOOLEAN_LITERAL, ProductionRule.TERMINAL);
                          id.setValue(b);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
                        :}
						| STRINGLITERAL:s
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.STRING_LITERAL);
                         Node id = new Node(LeftHand.STRING_LITERAL, ProductionRule.TERMINAL);
                         id.setValue(s);
                         tmp.getChildren().add(id);
                         RESULT = tmp;
                        :}
						| NULL:n
						{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.NULL);
                          Node id = new Node(LeftHand.NULL, ProductionRule.TERMINAL);
                          id.setValue(n);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
                        :}
						;