import java_cup.runtime.*;


/* August 1999 - modified by Gerwin Klein <lsf@jflex.de>
                 to interface with JFlex scanners,
                 allows empty semicolon in class decls.
  
  changed productions:

  class_member_declaration ::=
	  	field_declaration
  	|	method_declaration
    [..]
  	|	interface_declaration
    | SEMICOLON
  	;

  interface_member_declaration ::=
  		constant_declaration
	  |	abstract_method_declaration
  	|	class_declaration
  	|	interface_declaration
    | SEMICOLON
	  ;

*/


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/

parser code  {:
    public static Node root;

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal STRING, VOID, INT, DOUBLE, BOOL;
terminal CLASS;
terminal INTERFACE;
terminal NULL;
terminal THIS;
terminal EXTENDS;
terminal IMPLEMENTS;
terminal FOR;
terminal WHILE;
terminal IF, ELSE;
terminal RETURN;
terminal BREAK;
terminal CONTINUE;
terminal NEW;
terminal NEWARRAY;
terminal PRINT;
terminal READINTEGER;
terminal READLINE;
terminal DTOI;
terminal ITOB;
terminal ITOD;
terminal BTOI;
terminal PRIVATE, PUBLIC, PROTECTED;
terminal TRUE, FALSE;
terminal GT, LT, GTEQ, LTEQ;
terminal QUESTION;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, DIV, COMP, NOT, MOD;
terminal DOT;
terminal LBRACK, RBRACK;
terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, EQ, MULT, SEMICOLON, COLON;
terminal UNDEFINED_TOKEN;


terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number DOUBLE_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.Boolean BOOLEAN_LITERAL;


//in ja benevisiiiiid
nonterminal Program;
nonterminal Decl;
nonterminal VariableDecl;
nonterminal Variable;
nonterminal Type;
nonterminal FunctionDecl;
nonterminal Formals;
nonterminal ClassDecl;
nonterminal Field;


nonterminal AccessMode;
nonterminal InterfaceDecl;
nonterminal Prototype;
nonterminal StmtBlock;
nonterminal Stmt;
nonterminal IfStmt;
nonterminal WhileStmt;
nonterminal ForStmt;

nonterminal ReturnStmt;
nonterminal BreakStmt;
nonterminal ContinueStmt;
nonterminal PrintStmt;
nonterminal Expr;
nonterminal LValue;
nonterminal Call;
nonterminal Actuals;
nonterminal Constant;

nonterminal DeclPlus;
nonterminal VariablePlus;
nonterminal ExtendStmt;
nonterminal ImplementsStmt;
nonterminal IdentifierImplementsStmt;
nonterminal FieldStar;
nonterminal Prototype_star;
nonterminal VariableDecl_star;
nonterminal Stmt_star;
nonterminal Expr_Stmt;
nonterminal else_Stmt;
nonterminal Expr_plus;


precedence left ELSE;
precedence right EQ;
precedence left OROR;
precedence left ANDAND;
precedence left EQEQ, NOTEQ;
precedence left GT, GTEQ, LT, LTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOT, MINUS;
precedence left LBRACK, DOT;
//precedence left IDENTIFIER;

start with Program;

Program ::= DeclPlus:d {: Node tmp = new Node(LeftHand.Program, ProductionRule.DeclPlus); tmp.getChildren().add((Node) d);
                        RESULT = tmp; root = tmp;:};
DeclPlus ::= Decl:d {:

:} | Decl DeclPlus;
Decl ::= VariableDecl | FunctionDecl | ClassDecl | InterfaceDecl;
VariableDecl ::= Variable SEMICOLON;
Variable ::= Type:t IDENTIFIER:i{:
    Node tmp = new Node(NonTerminal.Variable, ProductionRule.TYPE_IDENTIFIER);
    tmp.getChildren().add((Node) t);

    Node id = new Node(NoneTerminal.IDENTIFIER, ProductionRule.IDENTIFIER);
    id.setValue(i);
    tmp.getChildren().add(id);
    RESULT = tmp;
:};
Type ::= Type LBRACK RBRACK | IDENTIFIER %prec MULT | INT | DOUBLE | STRING | BOOL ;
FunctionDecl ::= Type IDENTIFIER  LPAREN Formals RPAREN StmtBlock | VOID IDENTIFIER LPAREN Formals RPAREN StmtBlock;
VariablePlus ::= Variable | Variable COMMA VariablePlus;
Formals ::= VariablePlus | ;
ExtendStmt ::= EXTENDS IDENTIFIER |;
ImplementsStmt ::= IMPLEMENTS IdentifierImplementsStmt|;
IdentifierImplementsStmt ::= IDENTIFIER COMMA IdentifierImplementsStmt | IDENTIFIER;
FieldStar ::= Field FieldStar |;
Field ::= AccessMode VariableDecl | AccessMode FunctionDecl;
ClassDecl ::= CLASS IDENTIFIER ExtendStmt ImplementsStmt LBRACE FieldStar RBRACE;

AccessMode ::= PRIVATE | PROTECTED | PUBLIC |  ;
InterfaceDecl ::= INTERFACE IDENTIFIER LBRACE Prototype_star RBRACE;
Prototype_star ::=  Prototype Prototype_star | ;
Prototype ::= Type IDENTIFIER LPAREN Formals RPAREN SEMICOLON | VOID IDENTIFIER LPAREN Formals RPAREN SEMICOLON;
StmtBlock ::= LBRACE VariableDecl_star Stmt_star RBRACE;
VariableDecl_star ::= VariableDecl VariableDecl_star | %prec PLUS;
Stmt_star ::= Stmt Stmt_star | ;
Stmt ::=  Expr_Stmt  SEMICOLON | IfStmt | WhileStmt | ForStmt | BreakStmt | ContinueStmt | ReturnStmt | PrintStmt | StmtBlock;
Expr_Stmt ::= Expr | ;
IfStmt ::= IF LPAREN Expr RPAREN Stmt else_Stmt;
else_Stmt ::= ELSE Stmt |;
WhileStmt ::= WHILE LPAREN Expr RPAREN Stmt;
ForStmt ::= FOR LPAREN  Expr_Stmt  SEMICOLON Expr SEMICOLON  Expr_Stmt  RPAREN Stmt;

ReturnStmt ::= RETURN  Expr SEMICOLON | RETURN SEMICOLON;
BreakStmt ::= BREAK SEMICOLON;
ContinueStmt ::= CONTINUE SEMICOLON;
//+ ro doros kon
PrintStmt ::= PRINT LPAREN Expr_plus RPAREN SEMICOLON;
Expr_plus ::= Expr | Expr COMMA Expr_plus;

Expr ::= LValue:l EQ Expr:e{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue_EQ_Expr);
                                tmp.getChildren().add(l);
                                tmp.getChildren().add(e);
                                RESULT = tmp;
:} | Constant:c {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Constant);
                    tmp.getChildren().add(c);
                    RESULT = tmp;
:} | LValue:l{:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue);
                 tmp.getChildren().add(l);
                 RESULT = tmp;
 :} | THIS:t {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue_EQ_Expr);
                 Node id = new Node(LeftHand.Expr, ProductionRule.THIS);
                 id.setValue(t);
                 tmp.getChildren().add(t);
                 RESULT = tmp;
 :}| Call:c {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Call);
                tmp.getChildren().add(c);
                RESULT = tmp;
  :}| LPAREN Expr:e RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LPAREN_Expr_RPAREN);
                                tmp.getChildren().add(e);
                                RESULT = tmp;
:}| Expr:e1 PLUS Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue_EQ_Expr);
                              tmp.getChildren().add(e1);
                              tmp.getChildren().add(e2);
                              RESULT = tmp;
:}| Expr:e1 MINUS Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MINUS_Expr);
                            tmp.getChildren().add(e1);
                            tmp.getChildren().add(e2);
                            RESULT = tmp;
:}| Expr:e1 MULT Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MULT_Expr);
                            tmp.getChildren().add(e1);
                            tmp.getChildren().add(e2);
                            RESULT = tmp;
:} | Expr:e1 DIV Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_DIV_Expr);
                             tmp.getChildren().add(e1);
                             tmp.getChildren().add(e2);
                             RESULT = tmp;
 :} | Expr:e1 MOD Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MOD_Expr);
                        tmp.getChildren().add(e1);
                        tmp.getChildren().add(e2);
                        RESULT = tmp;
:}  | MINUS Expr:e1 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.MINUS_Expr);
                        tmp.getChildren().add(e1);
                        RESULT = tmp;
:} | Expr:e1 LT Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_LT_Expr);
                            tmp.getChildren().add(e1);
                            tmp.getChildren().add(e2);
                            RESULT = tmp;
:} | Expr:e1 LTEQ Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_LTEQ_Expr);
                              tmp.getChildren().add(e1);
                              tmp.getChildren().add(e2);
                              RESULT = tmp;
:} |
Expr:e1 GT Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_GT_Expr);
                       tmp.getChildren().add(e1);
                       tmp.getChildren().add(e2);
                       RESULT = tmp;
:} | Expr:e1 GTEQ Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_GTEQ_Expr);
                              tmp.getChildren().add(e1);
                              tmp.getChildren().add(e2);
                              RESULT = tmp;
:} | Expr:e1 EQEQ Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_EQEQ_Expr);
                              tmp.getChildren().add(e1);
                              tmp.getChildren().add(e2);
                              RESULT = tmp;
:} | Expr:e1 NOTEQ Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_NOTEQ_Expr);
                               tmp.getChildren().add(e1);
                               tmp.getChildren().add(e2);
                               RESULT = tmp;
:} | Expr:e1 ANDAND Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_ANDAND_Expr);
                                tmp.getChildren().add(e1);
                                tmp.getChildren().add(e2);
                                RESULT = tmp;
:} | Expr:e1 OROR Expr:e2 {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_OROR_Expr);
                              tmp.getChildren().add(e1);
                              tmp.getChildren().add(e2);
                              RESULT = tmp;
:} |
NOT Expr:e {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.NOT_Expr);
               tmp.getChildren().add(e);
               RESULT = tmp;
:}  | READINTEGER LPAREN RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.READINTEGER_LPAREN_RPAREN);
                                     RESULT = tmp;
:} | READLINE LPAREN RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.READLINE_LPAREN_RPAREN);
                                RESULT = tmp;
:} | NEW IDENTIFIER:i {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.NEW_IDENTIFIER);
                          Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                          id.setValue(i);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
:} | NEWARRAY LPAREN Expr:e COMMA Type:t RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.NEWARRAY_LPAREN_Expr_COMMA_Type_RPAREN);
                                                    tmp.getChildren(e);
                                                    tmp.getChildren().add(t);
                                                    RESULT = tmp;
:} |
ITOD LPAREN Expr:e RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.ITOD_LPAREN_Expr_RPAREN);
                            tmp.getChildren().add(e);
                            RESULT = tmp;
:}| DTOI LPAREN Expr:e RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.DTOI_LPAREN_Expr_RPAREN);
                                tmp.getChildren().add(e);
                                RESULT = tmp;
:}| ITOB LPAREN Expr:e RPAREN  {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.ITOB_LPAREN_Expr_RPAREN);
                                tmp.getChildren().add(e);
                                RESULT = tmp;
:}| BTOI LPAREN Expr:e RPAREN {:  Node tmp = new Node(LeftHand.Expr, ProductionRule.BTOI_LPAREN_Expr_RPAREN);
                               tmp.getChildren().add(e);
                               RESULT = tmp;
:};

LValue ::= IDENTIFIER:i  {:  Node tmp = new Node(LeftHand.LValue, ProductionRule.IDENTIFIER);
                             Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                             id.setValue(i);
                             tmp.getChildren().add(i);
                             RESULT = tmp;
:} | Expr:e DOT IDENTIFIER:i {:  Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_DOT_IDENTIFIER);
                              Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                              id.setValue(i);
                              tmp.getChildren().add(e);
                              tmp.getChildren().add(i);
                              RESULT = tmp;
 :} | Expr:e1 LBRACK Expr:e2 RBRACK{:  Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_LBRACK_Expr_RBRACK);
                            Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                            tmp.getChildren().add(e1);
                            tmp.getChildren().add(e2);
                            RESULT = tmp;
:};

Call ::= IDENTIFIER:i LPAREN Actuals:a RPAREN {:  Node tmp = new Node(LeftHand.Call, ProductionRule.IDENTIFIER_LPAREN_Actuals_RPAREN);
                                                 Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                                                 id.setValue(i);
                                                 tmp.getChildren().add(id);
                                                 tmp.getChildren().add(a);
                                                 RESULT = tmp;
  :}| Expr:e DOT IDENTIFIER:i LPAREN Actuals:a RPAREN {:  Node tmp = new Node(LeftHand.Call, ProductionRule.Expr_DOT_IDENTIFIER_LPAREN_Actuals_RPAREN);
                                                         Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                                                         id.setValue(i);
                                                         tmp.getChildren().add(e);
                                                         tmp.getChildren().add(id);
                                                         tmp.getChildren().add(a);
                                                         RESULT = tmp;
  :};

Actuals ::= Expr_plus:e{:  Node tmp = new Node(LeftHand.Actuals, ProductionRule.Expr_plus);
                          tmp.getChildren().add(e);
                          RESULT = tmp;
:} | {:  Node tmp = new Node(LeftHand.Constant, ProductionRule.INTEGER_LITERAL);
        Node id = new Node(LeftHand.Actuals, ProductionRule.NOTHING);
        RESULT = tmp;
:};

Constant ::= INTEGER_LITERAL:i {:  Node tmp = new Node(LeftHand.Constant, ProductionRule.INTEGER_LITERAL);
                                   Node id = new Node(LeftHand.INTEGER_LITERAL, ProductionRule.TERMINAL);
                                   id.setValue(i);
                                   tmp.getChildren().add(id);
                                   RESULT = tmp;
:}|
 DOUBLE_LITERAL:d {:  Node tmp = new Node(LeftHand.Constant, ProductionRule.DOUBLE_LITERAL);
                     Node id = new Node(LeftHand.DOUBLE_LITERAL, ProductionRule.TERMINAL);
                     id.setValue(d);
                     tmp.getChildren().add(id);
                     RESULT = tmp;
:} | BOOLEAN_LITERAL:b {:  Node tmp = new Node(LeftHand.Constant, ProductionRule.BOOLEAN_LITERAL);
                          Node id = new Node(LeftHand.BOOLEAN_LITERAL, ProductionRule.TERMINAL);
                          id.setValue(b);
                          tmp.getChildren().add(id);
                          RESULT = tmp;
:} | STRING_LITERAL:s {:  Node tmp = new Node(LeftHand.Constant, ProductionRule.STRING_LITERAL);
                         Node id = new Node(LeftHand.STRING_LITERAL, ProductionRule.TERMINAL);
                         id.setValue(s);
                         tmp.getChildren().add(id);
                         RESULT = tmp;
:} | NULL:n{:  Node tmp = new Node(LeftHand.Constant, ProductionRule.NULL);
              Node id = new Node(LeftHand.NULL, ProductionRule.TERMINAL);
              id.setValue(n);
              tmp.getChildren().add(id);
              RESULT = tmp;
:};

