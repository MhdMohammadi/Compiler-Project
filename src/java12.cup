import java_cup.runtime.*;


parser code  {:
    public static Node root;

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};
// defining terminals here
// arithmetic operators
terminal        PLUS, MINUS, MULTIPLY, DIVIDE, MOD, UMINUS,
				LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL, NOTEQUAL;
// logical operators
terminal	    AND, OR, NOT;
// dot
terminal        DOT;
// types
terminal        String INT, DOUBLE, BOOL, STRING;

// literals
terminal        String DECIMAL;
terminal        String FLOATINGPOINT;
terminal        String BOOLEANLITERAL;
terminal        String STRINGLITERAL;
terminal        NULL;

// signs
terminal		OPENBRACKET, CLOSEBRACKET, OPENCLOSEBRACKET, WS, OPENPARENTHESIS,
				CLOSEPARENTHESIS, OPENCURLYBRACES, CLOSECURLYBRACES;
// keywords
terminal        READINTEGER, READLINE, NEW, NEWARRAY, ITOD, DTOI, ITOB, BTOI,
				VOID, CLASS, INTERFACE,
				EXTENDS, IMPLEMENTS, COMMA, SEMICOLON, PRIVATE, PROTECTED, PUBLIC, IF, ELSE, WHILE, FOR, RETURN,
				BREAK, CONTINUE, PRINT, ASSIGN, THIS;
terminal        String IDENTIFIER;

// defining nonterminals
nonterminal     Program, DeclStar, Decl, VariableDecl, Variable, FunctionDecl, Formals, CommaVariables,
				ClassDecl, ClassDeclExtends, ClassDeclImplements, CommaIdentifiers, FieldStar, Field,
				AccessMode, InterfaceDecl, PrototypeStar, Prototype, StmtBlock, InsideStmtBlock, VariableDeclStar, StmtStar,
				Stmt, ExprPrime, IfStmt, ElsePrime, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt, PrintStmt,
				PrintCommaExpr, ActualsCommaExpr, Actuals;
// non-terminals with type
nonterminal     Type;
nonterminal     LValue;
nonterminal     Expr;
nonterminal     Constant;
nonterminal     Call;

// defining precedences
precedence left     ELSE;
precedence right    ASSIGN;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, NOTEQUAL;
precedence left     LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left     PLUS, MINUS;
precedence left     MULTIPLY, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     DOT, OPENBRACKET;
precedence left     OPENPARENTHESIS;

start with Program;

Program ::=             Decl DeclStar;

DeclStar ::=            Decl DeclStar
						| /*epsilon*/
						;

Decl ::=                VariableDecl
						| FunctionDecl
						| ClassDecl
						| InterfaceDecl
						;

VariableDecl ::=        Variable SEMICOLON;

Variable ::=            Type:type IDENTIFIER:id
						;

Type ::=                INT
						| DOUBLE
						| BOOL
						| STRING
                        | IDENTIFIER:e
						| Type:t OPENCLOSEBRACKET
						;

FunctionDecl ::=        Type:t IDENTIFIER:name OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						| VOID IDENTIFIER:name OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						;

Formals ::=             Variable:v CommaVariables
						| /*epsilon*/
						;
CommaVariables ::=      COMMA Variable CommaVariables
						| /*epsilon*/
						;

ClassDecl ::=           CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements OPENCURLYBRACES FieldStar CLOSECURLYBRACES;
ClassDeclExtends ::=    EXTENDS IDENTIFIER
						| /*epsilon*/
						;
ClassDeclImplements ::= IMPLEMENTS IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
CommaIdentifiers ::=    COMMA IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
FieldStar ::=           Field FieldStar
						| /*epsilon*/
						;

Field ::=               AccessMode VariableDecl
						| AccessMode FunctionDecl
						;

AccessMode ::=          PRIVATE {: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.PRIVATE);
                                tmp.setAccessMode(AccessMode.PRIVATE);
                                RESULT = tmp;:}
						| PROTECTED {: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.PROTECTED);
                                    tmp.setAccessMode(AccessMode.PROTECTED);
                                    RESULT = tmp;:}
						| PUBLIC {: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.PUBLIC);
						         tmp.setAccessMode(AccessMode.PUBLIC);
                                 RESULT = tmp;:}
						| /*epsilon*/
						{: Node tmp = new Node(LeftHand.AccessMode, ProductionRule.EPSILON);
                        RESULT = tmp;:} ;


InterfaceDecl ::=       INTERFACE IDENTIFIER:i OPENCURLYBRACES PrototypeStar:ps CLOSECURLYBRACES
{: Node tmp = new Node(LeftHand.InterfaceDecl, ProductionRule.INTERFACE_IDENTIFIER_OPENCURLYBRACES_PrototypeStar_CLOSECURLYBRACES);
Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
id.setValue(i);
tmp.getChildren().add(id);
tmp.getChildren().add((Node) ps);
RESULT = tmp;:};
PrototypeStar ::=       Prototype:p PrototypeStar:ps
{: Node tmp = new Node(LeftHand.PrototypeStar, ProductionRule.Prototype_PrototypeStar);
tmp.getChildren().add((Node) p);
tmp.getChildren().add((Node) ps);
RESULT = tmp;:}
						| /*epsilon*/
						{: Node tmp = new Node(LeftHand.PrototypeStar, ProductionRule.EPSILON);
                        RESULT = tmp;:}
						;

Prototype ::=           Type:t IDENTIFIER:i OPENPARENTHESIS Formals:f CLOSEPARENTHESIS SEMICOLON
{: Node tmp = new Node(LeftHand.Prototype, ProductionRule.Type_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_SEMICOLON);
tmp.getChildren().add((Node) t);
Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
id.setValue(i);
tmp.getChildren().add(id);
tmp.getChildren().add((Node) f);
RESULT = tmp;:}
						| VOID IDENTIFIER:i OPENPARENTHESIS Formals:f CLOSEPARENTHESIS SEMICOLON
						{: Node tmp = new Node(LeftHand.Prototype, ProductionRule.VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_SEMICOLON);
                        Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                        id.setValue(i);
                        tmp.getChildren().add(id);
                        tmp.getChildren().add((Node) f);
                        RESULT = tmp;:}
						;

StmtBlock ::=           OPENCURLYBRACES InsideStmtBlock:i CLOSECURLYBRACES
{: Node tmp = new Node(LeftHand.StmtBlock, ProductionRule.OPENCURLYBRACES_InsideStmtBlock_CLOSECURLYBRACES);
tmp.getChildren().add((Node) i);
RESULT = tmp;:};
InsideStmtBlock ::=     VariableDecl:v InsideStmtBlock:i
{: Node tmp = new Node(LeftHand.InsideStmtBlock, ProductionRule.VariableDecl_InsideStmtBlock);
tmp.getChildren().add((Node) v);
tmp.getChildren().add((Node) i);
RESULT = tmp;:}
						| StmtStar:s
						{: Node tmp = new Node(LeftHand.InsideStmtBlock, ProductionRule.StmtStar);
                        tmp.getChildren().add((Node) s);
                        RESULT = tmp;:}
						;
StmtStar ::=            Stmt:s StmtStar:ss
{: Node tmp = new Node(LeftHand.StmtStar, ProductionRule.Stmt_StmtStar);
tmp.getChildren().add((Node) s);
tmp.getChildren().add((Node) ss);
RESULT = tmp;:}
						| /*epsilon*/
						{: Node tmp = new Node(LeftHand.StmtStar, ProductionRule.EPSILON);
                        RESULT = tmp;:}
						;

Stmt ::=                ExprPrime:e SEMICOLON
{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ExprPrime_SEMICOLON);
tmp.getChildren().add((Node) e);
RESULT = tmp;:}
						| IfStmt:i
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.IfStmt);
                        tmp.getChildren().add((Node) i);
                        RESULT = tmp;:}
						| WhileStmt:w
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.WhileStmt);
                        tmp.getChildren().add((Node) w);
                        RESULT = tmp;:}
						| ForStmt:f
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ForStmt);
                        tmp.getChildren().add((Node) f);
                        RESULT = tmp;:}
						| BreakStmt:b
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.BreakStmt);
                        tmp.getChildren().add((Node) b);
                        RESULT = tmp;:}
						| ContinueStmt:c
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ContinueStmt);
                        tmp.getChildren().add((Node) c);
                        RESULT = tmp;:}
						| ReturnStmt:r
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.ReturnStmt);
                        tmp.getChildren().add((Node) r);
                        RESULT = tmp;:}
						| PrintStmt:p
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.PrintStmt);
                        tmp.getChildren().add((Node) p);
                        RESULT = tmp;:}
						| StmtBlock:s
						{: Node tmp = new Node(LeftHand.Stmt, ProductionRule.StmtBlock);
                        tmp.getChildren().add((Node) s);
                        RESULT = tmp;:}
						;

ExprPrime ::=           Expr:e
{: Node tmp = new Node(LeftHand.ExprPrime, ProductionRule.Expr);
                        tmp.getChildren().add((Node) e);
                        RESULT = tmp;:}
						| /*epsilon*/
						{: Node tmp = new Node(LeftHand.ExprPrime, ProductionRule.EPSILON);
						RESULT = tmp;:}
						;

IfStmt ::=              IF OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt:s ElsePrime:ep
{: Node tmp = new Node(LeftHand.IfStmt, ProductionRule.IF_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS_Stmt_ElsePrime);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) s);
tmp.getChildren().add((Node) ep);
RESULT = tmp;:}
                        ;

ElsePrime ::=           ELSE Stmt:s
{: Node tmp = new Node(LeftHand.ElsePrime, ProductionRule.ELSE_Stmt);
tmp.getChildren().add((Node) s);
RESULT = tmp;:}
						| /*epsilon*/
						{: Node tmp = new Node(LeftHand.ElsePrime, ProductionRule.EPSILON);
						RESULT = tmp;:}
                        ;


WhileStmt ::=           WHILE OPENPARENTHESIS Expr:e CLOSEPARENTHESIS Stmt:s
{: Node tmp = new Node(LeftHand.WhileStmt, ProductionRule.WHILE_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS_Stmt);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) s);
RESULT = tmp;:};

ForStmt ::=             FOR OPENPARENTHESIS ExprPrime:ep SEMICOLON Expr:e SEMICOLON ExprPrime:ep1 CLOSEPARENTHESIS Stmt:s
{: Node tmp = new Node(LeftHand.ForStmt, ProductionRule.FOR_OPENPARENTHESIS_ExprPrime_SEMICOLON_Expr_SEMICOLON_ExprPrime_CLOSEPARENTHESIS_Stmt);
tmp.getChildren().add((Node) ep);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) ep1);
tmp.getChildren().add((Node) s);
RESULT = tmp;:};

ReturnStmt ::=          RETURN ExprPrime:e SEMICOLON
{: Node tmp = new Node(LeftHand.ReturnStmt, ProductionRule.RETURN_ExprPrime_SEMICOLON);
tmp.getChildren().add((Node) e);
RESULT = tmp;:};

BreakStmt ::=           BREAK SEMICOLON
{: Node tmp = new Node(LeftHand.BreakStmt, ProductionRule.BREAK_SEMICOLON);
RESULT = tmp;:};

ContinueStmt ::=        CONTINUE SEMICOLON
{: Node tmp = new Node(LeftHand.ContinueStmt, ProductionRule.CONTINUE_SEMICOLON);
RESULT = tmp;:};

PrintStmt ::=           PRINT OPENPARENTHESIS Expr:e PrintCommaExpr:p CLOSEPARENTHESIS SEMICOLON
{: Node tmp = new Node(LeftHand.PrintStmt, ProductionRule.PRINT_OPENPARENTHESIS_Expr_PrintCommaExpr_CLOSEPARENTHESIS_SEMICOLON);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) p);
RESULT = tmp;:};

PrintCommaExpr ::=      COMMA Expr:e PrintCommaExpr:p
{: Node tmp = new Node(LeftHand.PrintCommaExpr, ProductionRule.COMMA_Expr_PrintCommaExpr);
tmp.getChildren().add((Node) e);
tmp.getChildren().add((Node) p);
RESULT = tmp;:}
						|
						{: Node tmp = new Node(LeftHand.PrintCommaExpr, ProductionRule.EPSILON);
						RESULT = tmp;:}
						/*epsilon*/
						;

Expr ::=                LValue:lv ASSIGN Expr:e
						| Constant:c
						| LValue:lv
						| THIS
						| Call:c
						| OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| Expr:e1 PLUS Expr:e2
						| Expr:e1 MINUS Expr:e2
						| Expr:e1 MULTIPLY Expr:e2
						| Expr:e1 DIVIDE Expr:e2
						| Expr:e1 MOD Expr:e2
						| MINUS Expr:e %prec UMINUS
                        | Expr:e1 LESS Expr:e2
						| Expr:e1 LESSEQUAL Expr:e2
						| Expr:e1 GREATER Expr:e2
						| Expr:e1 GREATEREQUAL Expr:e2
						| Expr:e1 EQUAL Expr:e2
						| Expr:e1 NOTEQUAL Expr:e2
						| Expr:e1 AND Expr:e2
						| Expr:e1 OR Expr:e2
						| NOT Expr:e
						| READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS
						| READLINE OPENPARENTHESIS CLOSEPARENTHESIS
						| NEW IDENTIFIER
						| NEWARRAY OPENPARENTHESIS Expr:e COMMA Type:t CLOSEPARENTHESIS
						| ITOD OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| DTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| ITOB OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						| BTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS
						;

LValue ::=              IDENTIFIER:id
						| Expr DOT IDENTIFIER
						| Expr:e1 OPENBRACKET Expr:e2 CLOSEBRACKET
						;

Call ::=                IDENTIFIER:functionID OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						| Expr:e DOT IDENTIFIER:id OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						;

Actuals ::=             Expr:e ActualsCommaExpr
						| /*epsilon*/
						;

ActualsCommaExpr ::=    COMMA Expr:e ActualsCommaExpr
						| /*epsilon*/
						;

Constant ::=            DECIMAL:d
						| FLOATINGPOINT:f
						| BOOLEANLITERAL:b
						| STRINGLITERAL:s
						| NULL:n
						;