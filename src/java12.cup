import java_cup.runtime.*;


/* August 1999 - modified by Gerwin Klein <lsf@jflex.de>
                 to interface with JFlex scanners,
                 allows empty semicolon in class decls.
  
  changed productions:

  class_member_declaration ::=
	  	field_declaration
  	|	method_declaration
    [..]
  	|	interface_declaration
    | SEMICOLON
  	;

  interface_member_declaration ::=
  		constant_declaration
	  |	abstract_method_declaration
  	|	class_declaration
  	|	interface_declaration
    | SEMICOLON
	  ;

*/


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/

parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal VOID,  INT,  DOUBLE, BOOL, STRING;
terminal CLASS;
terminal INTERFACE;
terminal NULL;
terminal THIS;
terminal EXTENDS;
terminal IMPLEMENTS;
terminal FOR;
terminal WHILE;
terminal IF, ELSE;
terminal RETURN;
terminal BREAK;
terminal CONTINUE;
terminal NEW;
terminal NEWARRAY;
terminal PRINT;
terminal READINTEGER;
terminal READLINE;
terminal DTOI;
terminal ITOB;
terminal ITOD;
terminal BTOI;
terminal PRIVATE, PUBLIC, PROTECTED;
terminal TRUE, FALSE;
terminal GT, LT, GTEQ, LTEQ;
terminal QUESTION;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, DIV, COMP, NOT, MOD;
terminal DOT;
terminal LBRACK, RBRACK;
terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, EQ, MULT, SEMICOLON, COLON;
terminal UNDEFINED_TOKEN;


terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number DOUBLE_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.Boolean BOOLEAN_LITERAL;


//in ja benevisiiiiid
nonterminal Program;
nonterminal Decl;
nonterminal VariableDecl;
nonterminal Variable;
nonterminal Type;
nonterminal FunctionDecl;
nonterminal Formals;
nonterminal ClassDecl;
nonterminal Field;

nonterminal AccessMode;
nonterminal InterfaceDecl;
nonterminal Prototype;
nonterminal StmtBlock;
nonterminal Stmt;
nonterminal IfStmt;
nonterminal WhileStmt;
nonterminal ForStmt;

nonterminal ReturnStmt;
nonterminal BreakStmt;
nonterminal ContinueStmt;
nonterminal PrintStmt;
nonterminal Expr;
nonterminal LValue;
nonterminal Call;
nonterminal Actuals;
nonterminal Constant;

nonterminal Decl_plus;
nonterminal Variable_plus;
nonterminal ExtendStmt;
nonterminal ImplementsStmt;
nonterminal IdentifierImplementsStmt;
nonterminal Prototype_star;
nonterminal VariableDecl_star;
nonterminal Stmt_star;
nonterminal Expr_Stmt;
nonterminal else_Stmt;

start with Program;

Program ::= Decl_plus | ;
Decl_plus ::= Decl | Decl Decl_plus;
Decl ::= VariableDecl | FunctionDecl | ClassDecl | InterfaceDecl;
VariableDecl ::= Variable;
Variable ::= Type IDENTIFIER;
Type ::= INT | DOUBLE | BOOL | STRING | IDENTIFIER | Type LBRACK RBRACK;
FunctionDecl ::= Type IDENTIFIER  LPAREN Formals RPAREN StmtBlock | VOID IDENTIFIER LPAREN Formals RPAREN StmtBlock;
Variable_plus ::= Variable | Variable Variable_plus;
Formals ::= Variable_plus COMMA | ;
ExtendStmt ::= EXTENDS IDENTIFIER |;
ImplementsStmt ::= IMPLEMENTS IdentiferImplementsStmt IDENTIFIER|;
IdentifierImplementsStmt ::= IMPLEMENTS COMMA IdentifierImplementsStmt |;
ClassDecl ::= CLASS IDENTIFIER ExtendStmt IMPLEMENTS  LBRACE Field RBRACE;
Field ::= AccessMode VariableDecl | AccessMode FunctionDecl;

AccessMode ::= PRIVATE | PROTECTED | PUBLIC |  ;
InterfaceDecl ::= INTERFACE IDENTIFIER LBRACE Prototype_star RBRACE;
Prototype_star ::=  Prototype Prototype_star | ;
Prototype ::= Type IDENTIFIER LPAREN Formals RPAREN SEMICOLON | VOID IDENTIFIER LPAREN Formals RPAREN SEMICOLON;
StmtBlock ::= LBRACE VariableDecl_star Stmt_star RBRACE;
VariableDecl_star ::= VariableDecl VariableDecl_star | ;
Stmt_star ::= Stmt Stmt_star | ;
Stmt ::=  Expr_Stmt  SEMICOLON | IfStmt | WhileStmt | ForStmt | BreakStmt | ContinueStmt | ReturnStmt | PrintStmt | StmtBlock;
Expr_Stmt ::= Expr | ;
IfStmt ::= IF LPAREN Expr RPAREN Stmt  else_Stmt  ;
else_Stmt ::= ELSE Stmt | ;
WhileStmt ::=  LPAREN Expr RPAREN Stmt;
ForStmt ::= FOR LPAREN  Expr_Stmt  SEMICOLON Expr SEMICOLON  Expr_Stmt  RPAREN Stmt;

ReturnStmt ::= return  Expr SEMICOLON | return  SEMICOLON;
BreakStmt ::= break SEMICOLON;
ContinueStmt ::= continue SEMICOLON;
//+ ro doros kon
PrintStmt ::= print LPAREN Expr+ COMMA RPAREN SEMICOLON;

Expr ::= LValue EQ Expr | Constant | LValue | this | Call | LPAREN Expr RPAREN | Expr PLUS Expr |
 Expr MINUS Expr | Expr MULT Expr | Expr DIV Expr | Expr MOD Expr | MINUS Expr | Expr LT Expr | Expr LTEQ Expr |
Expr GT Expr | Expr GTEQ Expr | Expr EQEQ Expr | Expr NOTEQ Expr | Expr ANDAND Expr | Expr OROR Expr |
  NOT Expr | ReadInteger LPAREN RPAREN | readLine LPAREN RPAREN | new ident | NewArray LPAREN Expr COMMA Type RPAREN |
itod LPAREN Expr RPAREN | dtoi LPAREN Expr RPAREN | itob LPAREN Expr RPAREN | btoi LPAREN Expr RPAREN;
LValue ::= ident | Expr DOT ident | Expr LBRACK Expr RBRACK;
Call ::= ident LPAREN Actuals RPAREN | Expr DOT ident LPAREN Actuals RPAREN;
//+ ro doros kon
Actuals ::= Expr+ COMMA | ;
Constant ::= intConstant | doubleConstant | boolConstant | stringConstant | null
